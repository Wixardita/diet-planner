<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diet Dose Planner â€¢ UC-friendly (Database locale Italia)</title>
  <style>
    :root{
      --bg:#0d1324;
      --bg2:#121a31;
      --card: rgba(255, 255, 255, .58);
      --stroke: rgba(0, 0, 0, .10);
      --stroke-strong: rgba(0, 0, 0, .12);
      --text: rgba(10,10,14,.92);
      --muted: rgba(10,10,14,.68);
      --muted2: rgba(10,10,14,.55);
      --shadow: 0 26px 62px rgba(7,14,30,.24), 0 6px 18px rgba(11,20,42,.14);
      --radius: 22px;
      --radius2: 28px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(140% 120% at 10% -10%, rgba(120,180,255,.22), transparent 46%),
        radial-gradient(110% 80% at 90% -20%, rgba(132,122,255,.20), transparent 52%),
        linear-gradient(165deg, var(--bg) 0%, var(--bg2) 55%, #111c35 100%);
      color: var(--text);
      overflow-x:hidden;
    }

    /* Animated background blobs */
    .bg-wrap{ position:fixed; inset:0; pointer-events:none; z-index:0; }
    canvas#bg{ width:100%; height:100%; display:block; }
    .noise{
      position:absolute; inset:-50px;
      background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='180' height='180'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/></filter><rect width='180' height='180' filter='url(%23n)' opacity='0.06'/></svg>");
      opacity:.22;
      mix-blend-mode: overlay;
    }

    .wrap{ position:relative; z-index:1; max-width:1100px; margin:0 auto; padding:28px 16px 40px; }
    header{ display:flex; gap:14px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap; }
    .title small{ color:var(--muted); display:block; margin-bottom:6px; }
    .title h1{ margin:0; font-size: clamp(26px, 3vw, 40px); letter-spacing:-0.01em; font-weight:700; }

    .pills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:12px; }
    .pill{
      padding:7px 10px; border-radius:999px; font-size:12px;
      background: linear-gradient(140deg, rgba(255,255,255,.70), rgba(255,255,255,.56));
      border:1px solid rgba(0,0,0,.10);
      color: var(--text);
      backdrop-filter: blur(14px) saturate(150%);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
    }
    .pill.warn{
      background: linear-gradient(140deg, rgba(255,236,190,.34), rgba(255,201,133,.22));
      border-color: rgba(255,226,176,.54);
      color: rgba(255,246,224,.97);
    }

    .collapse-panel{
      margin-top:12px;
      padding:14px;
      border-radius:20px;
      border:1px solid rgba(0,0,0,.10);
      background: linear-gradient(145deg, rgba(255,255,255,.62), rgba(255,255,255,.50));
      backdrop-filter: blur(16px) saturate(145%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.45), 0 12px 30px rgba(9,17,34,.16);
    }

    .btn{
      border:1px solid var(--stroke);
      background: linear-gradient(135deg, rgba(255,255,255,.60), rgba(255,255,255,.48));
      color: var(--text);
      padding:10px 14px;
      border-radius: 999px;
      cursor:pointer;
      backdrop-filter: blur(16px) saturate(145%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.50), 0 10px 24px rgba(11,24,50,.16);
      transition: transform .14s ease, background .18s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .btn:hover{ background: linear-gradient(135deg, rgba(255,255,255,.70), rgba(255,255,255,.58)); transform: translateY(-1px); box-shadow: inset 0 1px 0 rgba(255,255,255,.7), 0 12px 26px rgba(22,40,78,.20); }
    .btn:active{ transform: translateY(0); }
    .btn.primary{
      border-color: rgba(0,0,0,.12);
      background: linear-gradient(135deg, rgba(255,255,255,.64), rgba(245,250,255,.54));
      box-shadow: inset 0 1px 0 rgba(255,255,255,.62), 0 12px 30px rgba(20,34,64,.20);
    }
    .btn.primary:hover{ background: linear-gradient(135deg, rgba(255,255,255,.74), rgba(248,252,255,.62)); }

    .grid{ display:grid; grid-template-columns: 1.4fr .9fr; gap:14px; margin-top:16px; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background:
        linear-gradient(160deg, rgba(255,255,255,.65), rgba(255,255,255,.52)),
        var(--card);
      border:1px solid var(--stroke);
      border-top-color: var(--stroke-strong);
      border-left-color: rgba(0,0,0,.08);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      backdrop-filter: blur(24px) saturate(155%) brightness(1.1);
      overflow:hidden;
    }
    .card .hd{
      padding:16px 16px 12px;
      border-bottom:1px solid rgba(0,0,0,.10);
      display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .card .hd .kicker{ color: var(--muted); font-size:13px; }
    .card .hd .h2{ font-weight:700; letter-spacing:0.01em; }
    .card .bd{ padding:16px; }

    label{ display:block; color:var(--muted); font-size:12px; margin-bottom:6px; }
    input, select{
      width:100%;
      padding:11px 12px;
      border-radius: 999px;
      background: linear-gradient(145deg, rgba(255,255,255,.70), rgba(255,255,255,.55));
      border:1px solid rgba(0,0,0,.10);
      color: var(--text);
      outline:none;
      backdrop-filter: blur(14px) saturate(140%);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10), inset 0 1px 0 rgba(255,255,255,.5);
    }
    input::placeholder{ color: rgba(10,10,14,.55); }
    input:hover, select:hover{ background: linear-gradient(145deg, rgba(255,255,255,.76), rgba(255,255,255,.62)); }
    input:focus, select:focus{ border-color: rgba(0,0,0,.16); box-shadow: inset 0 0 0 1px rgba(0,0,0,.12), inset 0 1px 0 rgba(255,255,255,.62), 0 0 0 3px rgba(0,0,0,.10); }

    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 640px){ .row{ grid-template-columns: 1fr; } }

    .muted{ color: var(--muted2); font-size:12px; line-height:1.35; }

    .list{ display:flex; flex-direction:column; gap:10px; margin-top:12px; }
    .item{
      background: linear-gradient(145deg, rgba(255,255,255,.60), rgba(255,255,255,.48));
      border:1px solid rgba(0,0,0,.10);
      border-radius: 18px;
      padding:12px;
      display:flex; justify-content:space-between; gap:12px;
    }
    .item b{ display:block; margin-bottom:2px; }
    .item .meta{ color: var(--muted); font-size:12px; }
    .item .right{ text-align:right; }
    .custom-toggle{ cursor:pointer; user-select:none; }
    .custom-toggle .caret{ display:inline-block; transition: transform .15s ease; margin-right:6px; }
    .custom-toggle.open .caret{ transform: rotate(90deg); }
    .custom-form{ margin-top:10px; padding:12px; border:1px solid rgba(0,0,0,.10); border-radius:16px; background:linear-gradient(145deg, rgba(255,255,255,.60), rgba(255,255,255,.48)); }
    .custom-error{ color:#a13f3f; font-size:12px; margin-top:8px; }

    .bar{
      height:10px; border-radius:999px;
      background: rgba(255,255,255,.45);
      overflow:hidden;
      border:1px solid rgba(0,0,0,.10);
    }
    .bar > i{ display:block; height:100%; background: linear-gradient(90deg, rgba(155,213,255,.72), rgba(171,172,255,.74)); width: 0%; }
    .kv{ display:flex; justify-content:space-between; gap:12px; font-size:12px; color: var(--muted); margin: 6px 0 8px; }

    table{ width:100%; border-collapse:separate; border-spacing:0 8px; font-size:13px; }
    td{ padding:10px 10px; background: linear-gradient(145deg, rgba(255,255,255,.60), rgba(255,255,255,.48)); border:1px solid rgba(0,0,0,.10); }
    td:first-child{ border-radius:16px 0 0 16px; }
    td:last-child{ border-radius:0 16px 16px 0; text-align:right; font-family: var(--mono); }

    .x{ border:none; background:transparent; color:rgba(10,10,14,.78); cursor:pointer; font-size:16px; line-height:1; padding:0 6px; }

    .toggle{
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      border-radius: 999px;
      background: linear-gradient(145deg, rgba(255,255,255,.65), rgba(255,255,255,.52));
      border:1px solid rgba(0,0,0,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10), inset 0 1px 0 rgba(255,255,255,.55);
    }
    .toggle input{ width:auto; transform: translateY(1px); }

    footer{ margin-top:14px; color:var(--muted2); font-size:12px; }
  </style>
</head>
<body>
  <div class="bg-wrap">
    <canvas id="bg"></canvas>
    <div class="noise"></div>
  </div>

  <div class="wrap">
    <header>
      <div class="title">
        <small>Dose Planner â€¢ UC-friendly â€¢ Database locale (Italia) â€¢ dosi fisse per pasto</small>
        <h1>Diet Dose Planner (HTML)</h1>
        <div class="pills" id="pills"></div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button class="btn" id="btnProfileToggle">Scheda fisica â–¾</button>
        <button class="btn" id="btnReset">Reset oggi</button>
      </div>
    </header>

    <div id="profilePanel" class="collapse-panel" style="display:none;">
      <div class="row">
        <div>
          <label>Peso (kg)</label>
          <input id="profileWeight" type="number" min="0" step="0.1" />
        </div>
        <div>
          <label>Altezza (cm)</label>
          <input id="profileHeight" type="number" min="0" step="1" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>EtÃ </label>
          <input id="profileAge" type="number" min="0" step="1" />
        </div>
        <div>
          <label>Obiettivo</label>
          <select id="profileGoal">
            <option value="Mantenimento">Mantenimento</option>
            <option value="Aumento massa">Aumento massa</option>
            <option value="Dimagrimento">Dimagrimento</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Allenamenti a settimana</label>
          <input id="profileWorkouts" type="number" min="0" step="1" />
        </div>
        <div>
          <label>Ora allenamento</label>
          <input id="profileWorkoutTime" type="time" value="13:00" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Giorno di allenamento</label>
          <div class="toggle" title="Allenamento alle 13:00: aumenta carburante su spuntino mattina + pranzo">
            <input type="checkbox" id="isWorkout" />
            <label for="isWorkout" style="margin:0; color:var(--muted); font-size:12px;">Giorno di allenamento (13:00)</label>
          </div>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Proteine target (g/die)</label>
          <input id="profileProtein" type="number" min="0" step="0.1" />
        </div>
        <div>
          <label>Carbo target (g/die)</label>
          <input id="profileCarbs" type="number" min="0" step="0.1" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Grassi target (g/die)</label>
          <input id="profileFat" type="number" min="0" step="0.1" />
        </div>
        <div>
          <label>Calorie target (kcal/die)</label>
          <input id="profileKcal" type="number" min="0" step="1" />
        </div>
      </div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn primary" id="btnProfileSave">Salva</button>
        <button class="btn" id="btnProfileClose">Annulla/Chiudi</button>
      </div>
      <div class="muted" id="profileError" style="margin-top:8px; color:#ffd6d6;"></div>
    </div>

    <div id="dbErrorBanner" class="card" style="display:none; margin-top:16px; border-color:rgba(255,120,120,.45); background:rgba(120,20,20,.35);">
      <div class="bd">
        <b>Errore database locale:</b> impossibile caricare <code>data/foods_it_master.json</code>.
        Verifica che il file esista e sia un JSON valido. La ricerca Ã¨ disabilitata.
      </div>
    </div>

    <div class="grid">
      <!-- Left -->
      <div class="card">
        <div class="hd">
          <div>
            <div class="kicker">Scrivi un alimento (database locale)</div>
            <div class="h2">Cerca (Database locale Italia) â†’ aggiungi â†’ dosi per il pasto</div>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <select id="mealType" style="width: 220px;">
              <option value="breakfast">Colazione</option>
              <option value="snack1">Spuntino mattina</option>
              <option value="lunch" selected>Pranzo</option>
              <option value="snack2">Spuntino pomeriggio</option>
              <option value="dinner">Cena</option>
            </select>
            <button class="btn primary" id="btnLog">Registra pasto</button>
          </div>
        </div>

        <div class="bd">
          <div class="row">
            <div>
              <label>Cerca alimento</label>
              <input id="q" placeholder="Es: avocado, uova, riso basmati, yogurt greco, pollo..." />
              <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
                <button class="btn" id="btnSearch">Cerca</button>
                <button class="btn" id="btnClearMeal">Svuota selezione pasto</button>
              </div>
              <div class="muted" style="margin-top:8px">
                Fonte dati: <b>Database locale (Italia)</b>. Ricerca sempre offline sul file locale.
              </div>
            </div>

            <div>
              <label>Come funziona la dose (importantissimo)</label>
              <div class="muted">
                Le dosi sono calcolate <b>solo</b> su target giornalieri + ripartizione del pasto (e toggle allenamento).<br/>
                <b>NON</b> si auto-regola su quanto hai giÃ  mangiato: se fai il matto Ã¨ un problema tuo ðŸ˜„
              </div>
            </div>
          </div>

          <div class="list" id="results"></div>

          <div style="margin-top:14px; display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
            <div class="card" style="box-shadow:none;">
              <div class="hd">
                <div>
                  <div class="kicker">Pasto corrente</div>
                  <div class="h2">Ingredienti selezionati</div>
                </div>
                <div class="kicker">obiettivo pasto: <span id="mealKcal">â€”</span> kcal</div>
              </div>
              <div class="bd">
                <div id="mealItems" class="list"></div>
                <div style="margin-top:12px;">
                  <div class="kv"><span>Fibre insolubili (rischio)</span><span id="mealScore">â€”</span></div>
                  <div class="bar"><i id="scoreBar"></i></div>
                  <div class="kv" style="margin-top:6px;"><span>1 ok</span><span>10 evita</span></div>
                </div>
              </div>
            </div>

            <div class="card" style="box-shadow:none;">
              <div class="hd">
                <div>
                  <div class="kicker">Dosi suggerite</div>
                  <div class="h2">Grammi per ingrediente</div>
                </div>
              </div>
              <div class="bd">
                <table id="doseTable"></table>

                <div style="margin-top:12px;">
                  <div class="kv"><span>kcal</span><span id="mKcal">â€”</span></div>
                  <div class="kv"><span>Proteine</span><span id="mP">â€”</span></div>
                  <div class="kv"><span>Carbo</span><span id="mC">â€”</span></div>
                  <div class="kv"><span>Grassi</span><span id="mF">â€”</span></div>
                  <div class="kv"><span>Fibre totali (stima)</span><span id="mFi">â€”</span></div>
                  <div class="muted" id="mealKcalDebug">â€”</div>
                  <div class="muted" id="mealTargetsLine">â€”</div>
                  <div class="muted" id="mealMacroDeficit"></div>
                  <div class="muted" id="mealConstraintNote"></div>
                  <div class="muted">
                    Lo score 1â€“10 Ã¨ euristico: <b>fibre totali</b> + parole trigger (legumi, integrale, cavoli, insalateâ€¦). Puoi correggerlo alimento per alimento.
                  </div>
                </div>

              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- Right -->
      <div class="card">
        <div class="hd">
          <div>
            <div class="kicker">Dashboard giornata</div>
            <div class="h2">Tracking (facoltativo)</div>
          </div>
        </div>
        <div class="bd">
          <div id="dash"></div>

          <div style="margin-top:12px" class="card" style="box-shadow:none;">
            <div class="hd">
              <div>
                <div class="kicker">Registro di oggi</div>
                <div class="h2">Pasti registrati</div>
              </div>
            </div>
            <div class="bd" id="log"></div>
          </div>

          <footer>
            Dati nutrizionali: Database locale (Italia), ricerca 100% offline.
          </footer>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   Background animation (soft neon blobs)
---------------------------- */
(function(){
  const c = document.getElementById('bg');
  const ctx = c.getContext('2d');
  let w, h, t=0;

  const blobs = [
    {x:0.2, y:0.25, r:260, a:0.42, vx:0.00035, vy:0.00025, baseHue: 210}, // blue
    {x:0.78,y:0.35, r:320, a:0.34, vx:-0.00028,vy:0.00022, baseHue: 275}, // violet
    {x:0.45,y:0.85, r:360, a:0.30, vx:0.00020,vy:-0.00026, baseHue: 188}, // cyan
  ];

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    w = c.width = Math.floor(window.innerWidth * dpr);
    h = c.height = Math.floor(window.innerHeight * dpr);
    c.style.width = window.innerWidth + 'px';
    c.style.height = window.innerHeight + 'px';
    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  function draw(){
    t += 0.01;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#0d1324';
    ctx.fillRect(0,0,w,h);

    for(const b of blobs){
      b.x += b.vx * (1 + 0.6*Math.sin(t*0.8));
      b.y += b.vy * (1 + 0.6*Math.cos(t*0.7));
      if(b.x < -0.2) b.x = 1.2;
      if(b.x > 1.2) b.x = -0.2;
      if(b.y < -0.2) b.y = 1.2;
      if(b.y > 1.2) b.y = -0.2;

      const cx = b.x*w, cy = b.y*h;
      const rr = b.r * (0.85 + 0.25*Math.sin(t*0.9 + b.x*8));

      // Neon hue shift: slow RGB-like drift
      const hue = (((b.baseHue ?? 220) + t*11 + (Math.sin(t*0.45 + b.r)*14)) % 360);
      const hue2 = (hue + 26) % 360;

      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr*2.2);
      grad.addColorStop(0, `hsla(${hue}, 98%, 74%, ${b.a})`);
      grad.addColorStop(0.35, `hsla(${hue2}, 96%, 70%, ${b.a*0.42})`);
      grad.addColorStop(1, `hsla(${hue2}, 98%, 62%, 0)`);

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, rr*2.2, 0, Math.PI*2);
      ctx.fill();
    }
    requestAnimationFrame(draw);
  }
  draw();
})();

/* ---------------------------
   App state & helpers
---------------------------- */
const LS = (k) => 'dietDosePlannerHTML_OFF:' + k;
const $ = (id) => document.getElementById(id);
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const r1 = (n)=>Math.round(n);
const r01 = (n)=>Math.round(n*10)/10;

// Base split (rest day)
const SPLIT_REST = { breakfast: .22, snack1: .10, lunch: .28, snack2: .10, dinner: .30 };
// Workout day @13:00: more fuel pre+post (snack1 + lunch), slightly less at dinner
const SPLIT_WORKOUT_13 = { breakfast: .20, snack1: .13, lunch: .32, snack2: .10, dinner: .25 };

let isWorkout = load('isWorkout', false);
let profile = loadProfile();
if(typeof profile?.isWorkoutDay === 'boolean') isWorkout = !!profile.isWorkoutDay;
let profileDraft = { ...profile };
$('isWorkout').checked = !!isWorkout;

let meal = []; // selected foods for current meal: {name, per100:{kcal,protein,carbs,fat,fiber}, score, source, hint}
let log  = load('log', []); // tracking only; DOES NOT affect doses
let doseAdjustState = {}; // per-row interactive grams/lock overrides

function todayKey(){
  const d=new Date();
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
}
function load(key, fallback){
  try{ const raw = localStorage.getItem(LS(key)); return raw ? JSON.parse(raw) : fallback; }
  catch(e){ return fallback; }
}
function save(key, value){ localStorage.setItem(LS(key), JSON.stringify(value)); }

function loadProfile(){
  try{
    const raw = localStorage.getItem('profile_v1');
    return raw ? JSON.parse(raw) : {};
  }catch(e){
    return {};
  }
}
function saveProfile(value){
  localStorage.setItem('profile_v1', JSON.stringify(value || {}));
}

function sumMacros(items){
  return items.reduce((a,it)=>{
    a.kcal += it.kcal||0;
    a.protein += it.protein||0;
    a.carbs += it.carbs||0;
    a.fat += it.fat||0;
    a.fiber += it.fiber||0;
    return a;
  }, {kcal:0,protein:0,carbs:0,fat:0,fiber:0});
}
function macrosForGrams(per100, grams){
  const m = grams/100;
  return {
    kcal: (per100.kcal||0)*m,
    protein:(per100.protein||0)*m,
    carbs:(per100.carbs||0)*m,
    fat:(per100.fat||0)*m,
    fiber:(per100.fiber||0)*m
  };
}
function weightedScore(arr){
  const totG = arr.reduce((s,x)=>s+(x.grams||0),0) || 1;
  return arr.reduce((s,x)=>s+(x.grams||0)*(x.score||5),0)/totG;
}

/* ---------------------------
   Insoluble-fiber risk score (heuristic)
---------------------------- */
const TRIGGERS = [
  {re:/legum|ceci|fagiol|lentic|pisell/i, add:3},
  {re:/brocc|cavol|bruxell|verza|cavolf/i, add:3},
  {re:/integral|crusca|segale/i, add:2},
  {re:/insalat|cicori|radicch|lattug|spinac/i, add:2},
  {re:/semi|chia|lino|sesamo/i, add:2},
  {re:/frutta\s*secca|mandorl|noc|arachid/i, add:2},
];
function guessScore(name, fiberPer100){
  let s = 1;
  s += clamp((fiberPer100||0)/2, 0, 5);
  for(const t of TRIGGERS){ if(t.re.test(name)) s += t.add; }
  return clamp(s,1,10);
}

/* ---------------------------
   Local DB lookup + fuzzy (offline only)
---------------------------- */
let localFoodsCache = null;
let baseFoodsCache = null;
let dbLoadError = '';
let customFoods = load('customFoods', []);

function setDbStatus(isOk, message=''){
  const banner = $('dbErrorBanner');
  const btn = $('btnSearch');
  dbLoadError = isOk ? '' : message;
  if(btn) btn.disabled = !isOk;
  if(banner){
    if(isOk){
      banner.style.display = 'none';
    }else{
      banner.style.display = 'block';
      banner.querySelector('.bd').innerHTML = `<b>Errore database locale:</b> ${escapeHtml(message)}. La ricerca Ã¨ disabilitata.`;
    }
  }
}

async function readJsonViaXHR(path){
  return new Promise((resolve, reject)=>{
    try{
      const xhr = new XMLHttpRequest();
      xhr.open('GET', path, true);
      xhr.overrideMimeType('application/json');
      xhr.onload = ()=>{
        if(xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)){
          try{ resolve(JSON.parse(xhr.responseText)); }
          catch(err){ reject(err); }
          return;
        }
        reject(new Error(`HTTP ${xhr.status}`));
      };
      xhr.onerror = ()=>reject(new Error('XHR failed'));
      xhr.send();
    }catch(err){
      reject(err);
    }
  });
}

async function readLocalJson(path){
  try{
    const res = await fetch(path, { cache: 'no-store' });
    if(!res.ok) throw new Error(`${path} non disponibile`);
    return await res.json();
  }catch(fetchErr){
    // In apertura diretta file:// alcuni browser bloccano fetch() con "Failed to fetch".
    if(location.protocol === 'file:'){
      return await readJsonViaXHR(path);
    }
    throw fetchErr;
  }
}

function mapLocalFoods(raw){
  return (Array.isArray(raw) ? raw : []).map((f)=>({
    name: String(f.name || '').trim(),
    aliases: Array.isArray(f.aliases) ? f.aliases.map((a)=>String(a || '').trim()).filter(Boolean) : [],
    per100: {
      kcal: Number(f.kcal || 0),
      protein: Number(f.protein || 0),
      carbs: Number(f.carbs || 0),
      fat: Number(f.fat || 0),
      fiber: Number(f.fiber || 0),
    },
    category: String(f.category || 'altro'),
    source: 'Database locale (Italia)',
    hint: f.category ? `(${f.category})` : ''
  })).filter((x)=>x.name);
}

async function loadLocalFoods(){
  if(localFoodsCache) return localFoodsCache;
  const dbFile = './data/foods_it_master.json';
  try{
    const raw = await readLocalJson(dbFile);
    const mapped = mapLocalFoods(raw);
    if(!mapped.length) throw new Error(`${dbFile} vuoto o non valido`);
    baseFoodsCache = mapped;
    localFoodsCache = mergeWithCustomFoods(baseFoodsCache, customFoods);
    setDbStatus(true);
    return localFoodsCache;
  }catch(e){
    const lastErr = e?.message || String(e);
    const protocolHint = location.protocol === 'file:' ? ' Avvia la pagina con un server locale per permettere il caricamento JSON.' : '';
    setDbStatus(false, `Impossibile caricare il database locale (${lastErr}).${protocolHint}`);
    throw new Error(lastErr);
  }
}

function singularizeWord(word){
  if(word.length <= 3) return word;
  if(/(ine|oni|ani)$/.test(word)) return word.slice(0,-1);
  if(/[aeios]$/.test(word)) return word.slice(0,-1);
  return word;
}

function normalizeForMatch(s){
  const n = normalizeText(s);
  if(!n) return '';
  return n.split(' ').map((w)=>singularizeWord(w)).join(' ').trim();
}

function mergeWithCustomFoods(baseFoods, customList){
  const byNorm = new Map();
  const put = (food)=>{
    const key = normalizeForMatch(food.name);
    if(!key) return;
    byNorm.set(key, food);
  };
  (baseFoods || []).forEach((f)=>put({ ...f }));
  (customList || []).forEach((f)=>put({ ...f, source:'Custom', hint:'(personalizzato)' }));
  return Array.from(byNorm.values());
}

function refreshFoodsCache(){
  localFoodsCache = mergeWithCustomFoods(baseFoodsCache || [], customFoods || []);
}

function normalizeText(s){
  return String(s || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[Ì€-Í¯]/g, '')
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function tokenizeWords(s){
  const n = normalizeText(s);
  return n ? n.split(' ').filter(Boolean) : [];
}

function similarityScore(a,b){
  const aa = normalizeText(a);
  const bb = normalizeText(b);
  if(!aa || !bb) return 0;
  const d = levenshtein(aa, bb);
  return 1 - (d / Math.max(aa.length, bb.length, 1));
}

function rankQueryAgainstTokens(queryTokens, tokens){
  if(!queryTokens.length || !tokens.length) return null;
  const bestPerToken = [];

  for(const q of queryTokens){
    let best = null;
    for(const token of tokens){
      if(token === q){
        best = { type: 0, similarity: 1 };
        break;
      }

      if(token.startsWith(q)){
        const sim = similarityScore(q, token);
        if(!best || best.type > 1 || (best.type === 1 && sim > best.similarity)){
          best = { type: 1, similarity: sim };
        }
      }

      const sim = similarityScore(q, token);
      if(sim >= 0.65 && (!best || best.type > 2 || (best.type === 2 && sim > best.similarity))){
        best = { type: 2, similarity: sim };
      }
    }

    if(!best) return null;
    bestPerToken.push(best);
  }

  return {
    matchType: Math.max(...bestPerToken.map((x)=>x.type)),
    similarity: bestPerToken.reduce((a,x)=>a+x.similarity,0) / bestPerToken.length
  };
}

function levenshtein(a,b){
  const m = a.length, n = b.length;
  if(!m) return n;
  if(!n) return m;
  const dp = Array.from({length:m+1}, ()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i;
  for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  return dp[m][n];
}

function localSearch(foods, term){
  const qn = normalizeForMatch(term);
  if(!qn) return [];

  return foods
    .map((f)=>{
      const nameNorm = normalizeForMatch(f.name);
      const aliasNorm = (f.aliases || []).map((a)=>normalizeForMatch(a)).filter(Boolean);
      if(nameNorm === qn){
        return { f, priority: 0, similarity: 1 };
      }
      if(aliasNorm.includes(qn)){
        return { f, priority: 1, similarity: 0.99 };
      }

      const nameSim = similarityScore(qn, nameNorm);
      const aliasSim = aliasNorm.reduce((best, a)=>Math.max(best, similarityScore(qn, a)), 0);
      const sim = Math.max(nameSim, aliasSim);
      if(sim < 0.65) return null;
      return { f, priority: 2, similarity: sim };
    })
    .filter(Boolean)
    .sort((a,b)=>(a.priority-b.priority) || (b.similarity-a.similarity) || (a.f.name.length-b.f.name.length))
    .slice(0,8)
    .map(({f})=>({ ...f, score: guessScore(f.name, f.per100.fiber) }));
}

function getSuggestions(foods, term, limit=3){
  const qn = normalizeForMatch(term);
  if(!qn) return [];
  return foods
    .map((f)=>{
      const candidates = [normalizeForMatch(f.name), ...(f.aliases||[]).map((a)=>normalizeForMatch(a))].filter(Boolean);
      let rank = 3;
      let sim = 0;
      for(const c of candidates){
        if(c === qn) rank = Math.min(rank, 0);
        else if(c.split(' ').includes(qn) || qn.split(' ').includes(c)) rank = Math.min(rank, 1);
        else if(c.split(' ').some((w)=>w.startsWith(qn))) rank = Math.min(rank, 2);
        sim = Math.max(sim, similarityScore(qn, c));
      }
      return { f, rank, sim };
    })
    .filter((x)=>x.sim >= 0.65 || x.rank <= 2)
    .sort((a,b)=>(a.rank-b.rank) || (b.sim-a.sim) || (a.f.name.length-b.f.name.length))
    .slice(0, limit)
    .map((x)=>x.f);
}

function customFormHtml(term, key){
  return `
    <div class="item custom-toggle" id="customToggle-${key}" onclick="toggleCustomForm('${key}')">
      <div><b><span class="caret">â–¶</span>Inserisci personalizzato</b></div>
    </div>
    <div id="customFormWrap-${key}" style="display:none;">
      <div class="custom-form">
        <div class="row">
          <div>
            <label>Nome</label>
            <input id="customName-${key}" placeholder="Es: Riso crudo" value="${escapeHtml(term || '')}" />
          </div>
          <div>
            <label>kcal</label>
            <input id="customKcal-${key}" type="number" min="0" step="0.1" placeholder="per 100g" />
          </div>
        </div>
        <div class="row" style="margin-top:10px;">
          <div><label>carboidrati (g)</label><input id="customCarbs-${key}" type="number" min="0" step="0.1" /></div>
          <div><label>proteine (g)</label><input id="customProtein-${key}" type="number" min="0" step="0.1" /></div>
        </div>
        <div class="row" style="margin-top:10px;">
          <div><label>grassi (g)</label><input id="customFat-${key}" type="number" min="0" step="0.1" /></div>
          <div><label>fibre (g)</label><input id="customFiber-${key}" type="number" min="0" step="0.1" /></div>
        </div>
        <div id="customError-${key}" class="custom-error" style="display:none;"></div>
        <div style="display:flex; gap:10px; margin-top:12px;">
          <button class="btn primary" onclick="saveCustomFood('${key}')">Salva</button>
          <button class="btn" onclick="cancelCustomForm('${key}')">Annulla</button>
        </div>
      </div>
    </div>
  `;
}

async function searchFoodsByTerm(q){
  const foods = await loadLocalFoods();
  const terms = q.split(',').map(x=>x.trim()).filter(Boolean);
  const queries = terms.length ? terms : [q.trim()];

  return queries.map((term)=>({
    term,
    results: localSearch(foods, term)
  }));
}

/* ---------------------------
   Dosing logic (fixed per-meal targets)
   - NO auto-adjust based on previous meals
---------------------------- */
function splitForDay(){
  return $('isWorkout').checked ? SPLIT_WORKOUT_13 : SPLIT_REST;
}

function profileHasRequiredTargets(p = profile){
  const required = ['kcal','protein','carbs','fat'];
  return required.every((k)=>Number.isFinite(Number(p?.[k])) && Number(p[k]) >= 0);
}

function effectiveTargets(){
  const p = profile || {};
  return {
    kcal: Math.max(0, Number(p.kcal) || 0),
    protein: Math.max(0, Number(p.protein) || 0),
    carbs: Math.max(0, Number(p.carbs) || 0),
    fat: Math.max(0, Number(p.fat) || 0)
  };
}

function mealMacroDeficitMessage(totals, target){
  const macros = [
    { key:'protein', label:'proteine' },
    { key:'carbs', label:'carboidrati' },
    { key:'fat', label:'grassi' }
  ];

  const deficits = macros
    .map((m)=>{
      const targetVal = Math.max(target[m.key] || 0, 0);
      const totalVal = Math.max(totals[m.key] || 0, 0);
      const missing = Math.max(0, targetVal - totalVal);
      const deficitPct = targetVal > 0 ? (missing / targetVal) : 0;
      return { ...m, missing, deficitPct };
    })
    .filter((x)=>x.deficitPct > 0.15)
    .sort((a,b)=>b.deficitPct-a.deficitPct);

  if(!deficits.length) return '';
  const top = deficits[0];
  return `Mancano ${r1(top.missing)}g di ${top.label} per bilanciare il pasto`;
}

function mealTargetFor(type){
  const split = splitForDay();
  const frac = split[type] ?? 0.25;
  const T = effectiveTargets();
  return {
    kcal: T.kcal*frac,
    protein: T.protein*frac,
    carbs: T.carbs*frac,
    fat: T.fat*frac
  };
}

function dominant(per100){
  const p=per100.protein||0, c=per100.carbs||0, f=per100.fat||0;
  const m=Math.max(p,c,f);
  return (m===p)?'protein':(m===c)?'carb':'fat';
}

function isOilOrButter(name){
  return /olio|burro/i.test(name||'');
}

function isVegetableLike(name){
  return /verdur|zucchin|melanz|peperon|pomodor|insalat|lattug|radicch|spinac|cetriol|carot|fagiolin|broccol|cavol|bietol|finocch/i.test(name||'');
}

function classifyIngredient(food){
  if(isOilOrButter(food.name)) return 'fat';
  if(isVegetableLike(food.name)) return 'vegetable';
  return dominant(food.per100);
}

function isProtectedOilName(name){
  return /olio|oil|burro|butter/i.test(name||'');
}

function doseStateFor(idx, dose){
  if(!doseAdjustState[idx]){
    doseAdjustState[idx] = {
      grams: null,
      locked: isProtectedOilName(dose.name)
    };
  }
  return doseAdjustState[idx];
}

function suggestDoses(){
  const type = $('mealType').value;
  const target = mealTargetFor(type);
  const allProteinOnly = meal.length > 0 && meal.every((f)=>classifyIngredient(f)==='protein');

  const capFor = (food)=>{
    const kind = classifyIngredient(food);
    if(kind==='protein') return allProteinOnly ? 300 : 250;
    if(kind==='carb') return 180;
    if(kind==='fat') return 25;
    if(kind==='vegetable') return 300;
    return 250;
  };

  const floorFor = (food)=>{
    const kind = classifyIngredient(food);
    if(kind==='protein') return 120;
    if(kind==='carb') return 80;
    return 0;
  };

  // start from sane bases
  let doses = meal.map((f, idx)=>{
    let base = 100;
    const dom = dominant(f.per100);
    if(dom==='protein') base=200;
    if(dom==='carb') base=120;
    if(dom==='fat') base=35;
    if(/olio|burro/i.test(f.name)) base=15;
    const minG = floorFor(f);
    const maxG = capFor(f);
    const rowState = doseStateFor(idx, f);
    const startGrams = rowState.grams==null ? base : Number(rowState.grams);
    return { ...f, grams: clamp(startGrams, minG, maxG), minG, maxG, locked: !!rowState.locked, startGrams: clamp(startGrams, minG, maxG) };
  });

  const W = { kcal: 6, protein: 3, carbs: 2, fat: 1 };
  const objective = (tot)=> (
    W.kcal * Math.abs(tot.kcal - target.kcal) +
    W.protein * Math.abs(tot.protein - target.protein) +
    W.carbs * Math.abs(tot.carbs - target.carbs) +
    W.fat * Math.abs(tot.fat - target.fat)
  );

  const cur = () => sumMacros(doses.map(d=>macrosForGrams(d.per100, d.grams)));

  // Phase 1: reduce excess protein first (10% tolerance)
  const proteinToleranceCap = target.protein * 1.10;
  const unlockedProteinItems = doses
    .filter((d)=>!d.locked && classifyIngredient(d)==='protein')
    .sort((a,b)=>b.grams-a.grams);
  const protectedMainProtein = unlockedProteinItems.find((d)=>d.grams > 80);

  const proteinFloorFor = (d)=>{
    if(d.locked) return d.grams;
    if(protectedMainProtein && protectedMainProtein.name===d.name) return 80;
    return 0;
  };

  let proteinGuard = 0;
  while(cur().protein > proteinToleranceCap + 0.05 && proteinGuard < 500){
    const candidate = doses
      .filter((d)=>!d.locked && classifyIngredient(d)==='protein' && d.grams - proteinFloorFor(d) >= 10)
      .map((d)=>{
        const proteinPerKcal = (d.per100.protein||0) / Math.max(d.per100.kcal||0, 1);
        const proteinPerGram = (d.per100.protein||0) / 100;
        return { d, score: proteinPerKcal * 1000 + proteinPerGram };
      })
      .sort((a,b)=>b.score-a.score)[0];

    if(!candidate) break;
    candidate.d.grams = Math.max(proteinFloorFor(candidate.d), candidate.d.grams - 10);
    proteinGuard++;
  }

  // Phase 2: fill deficits / trim remaining excesses
  const maxIters = 36;
  for(let i=0;i<maxIters;i++){
    const totals = cur();
    const deficits = {
      kcal: target.kcal - totals.kcal,
      protein: target.protein - totals.protein,
      carbs: target.carbs - totals.carbs,
      fat: target.fat - totals.fat
    };

    const focusOrder = ['kcal','protein','carbs','fat']
      .sort((a,b)=>Math.abs(deficits[b])*W[b]-Math.abs(deficits[a])*W[a]);
    let focus = focusOrder[0];
    if(deficits.carbs > 0){
      focus = 'carbs';
    }else if(deficits.fat > 0 && (deficits.protein > 0 || deficits.carbs > 0)){
      focus = focusOrder.find((k)=>k!=='fat') || 'fat';
    }

    const tryPick = (allowOils)=>{
      const baseObjective = objective(totals);
      const candidates = [];

      for(const d of doses){
        if(d.locked) continue;
        const cat = classifyIngredient(d);
        const isOil = isProtectedOilName(d.name);
        if(isOil && !allowOils) continue;

        const direction = deficits[focus] >= 0 ? 1 : -1;
        const roomUp = d.maxG - d.grams;
        const roomDown = d.grams - d.minG;
        let step = isOil ? 5 : 10;
        if(focus==='carbs' && direction > 0 && cat==='carb'){
          const largeStep = Math.floor(Math.min(150, roomUp) / 10) * 10;
          if(largeStep >= 10) step = largeStep;
        }
        if((direction > 0 && roomUp < step) || (direction < 0 && roomDown < step)) continue;

        if(cat==='vegetable' && Math.abs((d.grams + direction*step) - d.startGrams) > 40) continue;

        const ng = clamp(d.grams + direction*step, d.minG, d.maxG);
        if(Math.abs(ng - d.grams) < 0.1) continue;

        const prev = d.grams;
        d.grams = ng;
        const nextTotals = cur();
        d.grams = prev;

        const density = (d.per100[focus]||0)/100;
        const improvement = baseObjective - objective(nextTotals);
        let priority = 0;
        if(focus==='carbs' && cat==='carb') priority = 0.45;
        if(focus==='protein' && cat==='protein') priority = 0.2;
        if(focus==='kcal' && (cat==='carb' || cat==='protein')) priority = 0.1;
        if(focus==='fat' && deficits.fat > 0 && cat==='fat') priority = 0.15;
        if(isOil) priority -= 0.5;

        candidates.push({ d, ng, score: improvement + density*0.01 + priority });
      }

      candidates.sort((a,b)=>b.score-a.score);
      return candidates[0];
    };

    let pick = tryPick(false);
    if(!pick){
      pick = tryPick(true);
    }
    if(!pick || pick.score <= 0){
      break;
    }
    pick.d.grams = pick.ng;
  }

  // round + clamp
  doses = doses.map(d=>{
    let g = d.grams;
    if(isOilOrButter(d.name)) g = Math.round(g/5)*5;
    else g = Math.round(g/10)*10;
    g = clamp(g, 0, d.maxG);
    return { ...d, grams:g };
  });

  let totals = cur();
  if(totals.kcal > target.kcal){
    let guard = 0;
    while(totals.kcal > target.kcal + 0.5 && guard < 300){
      const candidate = doses
        .filter((d)=>!isOilOrButter(d.name) && d.grams > 0)
        .sort((a,b)=>((b.per100.kcal||0) - (a.per100.kcal||0)))[0];
      if(!candidate) break;
      candidate.grams = Math.max(0, candidate.grams - (candidate.grams % 10 === 0 ? 10 : 5));
      totals = cur();
      guard++;
    }
  }

  totals = cur();
  const pDevPct = Math.abs(totals.protein-target.protein)/Math.max(target.protein,1)*100;
  const cDevPct = Math.abs(totals.carbs-target.carbs)/Math.max(target.carbs,1)*100;
  const fDevPct = Math.abs(totals.fat-target.fat)/Math.max(target.fat,1)*100;

  const canAdjustMacro = (macro, direction)=>{
    const step = macro==='fat' ? 5 : 10;
    return doses.some((d)=>{
      if(d.locked) return false;
      if((d.per100[macro]||0) <= 0) return false;
      const room = direction > 0 ? (d.maxG - d.grams) : (d.grams - d.minG);
      return room >= step;
    });
  };

  const macroDevs = {
    protein: pDevPct,
    carbs: cDevPct,
    fat: fDevPct
  };
  const macroTol = {
    protein: 18,
    carbs: 18,
    fat: 25
  };
  const outsideMacros = Object.keys(macroDevs).filter((k)=>macroDevs[k] > macroTol[k]);
  const noUnlockedFixes = outsideMacros.length > 0 && outsideMacros.every((macro)=>{
    const direction = (target[macro] - totals[macro]) >= 0 ? 1 : -1;
    return !canAdjustMacro(macro, direction);
  });
  const constrainedApprox = outsideMacros.length > 0 && noUnlockedFixes;

  doses.forEach((d, idx)=>{
    const rowState = doseStateFor(idx, d);
    rowState.grams = d.grams;
    rowState.locked = !!d.locked;
  });

  return { doses, totals, target, constrainedApprox };
}

/* ---------------------------
   UI rendering
---------------------------- */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (m)=>({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
  })[m]);
}

function renderPills(){
  const tk = todayKey();
  const split = splitForDay();
  const T = effectiveTargets();
  const warningPill = profileHasRequiredTargets() ? '' : '<span class="pill warn">Completa la Scheda fisica per calcoli precisi</span>';
  $('pills').innerHTML = `
    ${warningPill}
    <span class="pill">Target: ${r1(T.kcal)} kcal</span>
    <span class="pill">P ${r1(T.protein)}g</span>
    <span class="pill">C ${r1(T.carbs)}g</span>
    <span class="pill">F ${r1(T.fat)}g</span>
    <span class="pill">Oggi: ${tk}</span>
    <span class="pill">${$('isWorkout').checked ? 'Allenamento 13:00' : 'Riposo'}</span>
    <span class="pill">Split: col ${Math.round(split.breakfast*100)}% â€¢ sp1 ${Math.round(split.snack1*100)}% â€¢ pran ${Math.round(split.lunch*100)}% â€¢ sp2 ${Math.round(split.snack2*100)}% â€¢ cena ${Math.round(split.dinner*100)}%</span>
  `;
}

function totalsToday(){
  const tk=todayKey();
  const entries = log.filter(e=>e.day===tk);
  const items = entries.flatMap(e=>e.items);
  return sumMacros(items);
}

function renderDashboard(){
  const t = totalsToday();
  const T = effectiveTargets();
  const rows = [
    ['Calorie', t.kcal, T.kcal, 'kcal'],
    ['Proteine', t.protein, T.protein, 'g'],
    ['Carbo', t.carbs, T.carbs, 'g'],
    ['Grassi', t.fat, T.fat, 'g'],
  ];
  const html = rows.map(([lab,val,tgt,unit])=>{
    const pct = clamp((val/(tgt||1))*100, 0, 140);
    return `
      <div style="margin-bottom:12px;">
        <div class="kv"><span>${lab}</span><span>${r1(val)}/${r1(tgt)} ${unit}</span></div>
        <div class="bar"><i style="width:${pct}%;"></i></div>
      </div>
    `;
  }).join('');
  $('dash').innerHTML = html + `<div class="muted">Tracking facoltativo: non influenza le dosi.</div>`;
}

function prettyMealType(mt){
  return ({
    breakfast:'Colazione',
    snack1:'Spuntino mattina',
    lunch:'Pranzo',
    snack2:'Spuntino pomeriggio',
    dinner:'Cena'
  })[mt] || mt;
}

function renderLog(){
  const tk = todayKey();
  const entries = log.filter(e=>e.day===tk);
  if(!entries.length){
    $('log').innerHTML = `<div class="muted">Nessun pasto registrato oggi.</div>`;
    return;
  }
  $('log').innerHTML = entries.map(e=>{
    const totals = sumMacros(e.items);
    const score = weightedScore(e.items);
    const time = new Date(e.createdAt).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    return `
      <div class="item">
        <div>
          <b>${prettyMealType(e.mealType)}</b>
          <div class="meta">${time} â€¢ ${r1(totals.kcal)} kcal â€¢ P ${r1(totals.protein)}g â€¢ C ${r1(totals.carbs)}g â€¢ F ${r1(totals.fat)}g â€¢ score ${r01(score)}/10</div>
          <div class="meta">${e.items.map(it=>`${escapeHtml(it.name)} ${r1(it.grams)}g`).join(' Â· ')}</div>
        </div>
        <div class="right">
          <button class="x" onclick="removeEntry('${e.id}')">âœ•</button>
        </div>
      </div>
    `;
  }).join('');
}

function renderMeal(){
  const type = $('mealType').value;
  const mt = mealTargetFor(type);
  $('mealKcal').textContent = r1(mt.kcal);

  if(!meal.length){
    $('mealItems').innerHTML = `<div class="muted">Nessun ingrediente selezionato.</div>`;
    $('doseTable').innerHTML = '';
    $('mealScore').textContent = 'â€”';
    $('scoreBar').style.width = '0%';
    $('mKcal').textContent = 'â€”';
    $('mP').textContent = 'â€”';
    $('mC').textContent = 'â€”';
    $('mF').textContent = 'â€”';
    $('mFi').textContent = 'â€”';
    $('mealKcalDebug').textContent = 'â€”';
    $('mealTargetsLine').textContent = 'â€”';
    $('mealMacroDeficit').textContent = '';
    $('mealConstraintNote').textContent = '';
    return;
  }

  $('mealItems').innerHTML = meal.map((f,idx)=>`
    <div class="item">
      <div>
        <b>${escapeHtml(f.name)} <span class="meta">${escapeHtml(f.hint||'')}</span></b>
        <div class="meta">Fonte: ${f.source} â€¢ per 100g: ${r1(f.per100.kcal)} kcal Â· P ${r01(f.per100.protein)} Â· C ${r01(f.per100.carbs)} Â· F ${r01(f.per100.fat)} Â· Fib ${r01(f.per100.fiber)}</div>
        <div class="meta">Score: <b>${r01(f.score)}/10</b> (modificabile)</div>
      </div>
      <div class="right">
        <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
          <input style="width:86px; text-align:right;" type="number" min="1" max="10" step="0.5"
            value="${f.score}"
            onchange="setFoodScore(${idx}, this.value)" />
          <button class="x" onclick="removeMealItem(${idx})">âœ•</button>
        </div>
      </div>
    </div>
  `).join('');

  const solved = suggestDoses();
  const doses = solved.doses;
  const totals = solved.totals;
  const score = weightedScore(doses);

  $('doseTable').innerHTML = doses.map((d,idx)=>`
    <tr>
      <td>${escapeHtml(d.name)}</td>
      <td>
        <div style="display:flex; gap:8px; align-items:center; justify-content:flex-end;">
          <input style="width:86px; text-align:right;" type="number" min="0" step="5" value="${r1(d.grams)}"
            onchange="setDoseGrams(${idx}, this.value)" />
          <label style="margin:0; display:flex; align-items:center; gap:4px; font-size:12px; color:var(--muted);">
            <input type="checkbox" ${d.locked ? 'checked' : ''} onchange="setDoseLock(${idx}, this.checked)" /> lock
          </label>
        </div>
      </td>
    </tr>
  `).join('');

  $('mKcal').textContent = `${r1(totals.kcal)} kcal`;
  $('mP').textContent = `${r1(totals.protein)} g`;
  $('mC').textContent = `${r1(totals.carbs)} g`;
  $('mF').textContent = `${r1(totals.fat)} g`;
  $('mFi').textContent = `${r01(totals.fiber)} g`;
  $('mealKcalDebug').textContent = `Target pasto: ${r1(mt.kcal)} kcal â€¢ Proposto: ${r1(totals.kcal)} kcal`;
  const dev = (cur, tgt)=>((cur-tgt)/Math.max(tgt,1))*100;
  $('mealTargetsLine').textContent = `Target K/P/C/F: ${r1(solved.target.kcal)} / ${r1(solved.target.protein)} / ${r1(solved.target.carbs)} / ${r1(solved.target.fat)} â€¢ Corrente: ${r1(totals.kcal)} / ${r1(totals.protein)} / ${r1(totals.carbs)} / ${r1(totals.fat)} â€¢ Dev%: kcal ${r1(dev(totals.kcal, solved.target.kcal))}% Â· P ${r1(dev(totals.protein, solved.target.protein))}% Â· C ${r1(dev(totals.carbs, solved.target.carbs))}% Â· F ${r1(dev(totals.fat, solved.target.fat))}%`;
  $('mealMacroDeficit').textContent = mealMacroDeficitMessage(totals, solved.target);
  $('mealConstraintNote').textContent = solved.constrainedApprox ? 'Vincoli troppo stretti: risultato approssimato' : '';

  $('mealScore').textContent = `${r01(score)}/10`;
  const pct = clamp(((score-1)/9)*100, 0, 100);
  $('scoreBar').style.width = pct + '%';
}

function renderAll(){
  renderPills();
  renderDashboard();
  renderLog();
  renderMeal();
}

/* ---------------------------
   Actions
---------------------------- */
window.removeMealItem = function(idx){
  meal.splice(idx,1);
  doseAdjustState = {};
  renderMeal();
}
window.setFoodScore = function(idx, v){
  meal[idx].score = clamp(Number(v)||5, 1, 10);
  renderMeal();
}
window.setDoseLock = function(idx, isLocked){
  const st = doseStateFor(idx, meal[idx]||{name:''});
  st.locked = !!isLocked;
  renderMeal();
}
window.setDoseGrams = function(idx, v){
  const d = meal[idx];
  if(!d) return;
  const maxG = classifyIngredient(d)==='fat' ? 25 : classifyIngredient(d)==='carb' ? 180 : classifyIngredient(d)==='protein' ? 250 : classifyIngredient(d)==='vegetable' ? 300 : 250;
  const st = doseStateFor(idx, d);
  st.grams = clamp(Number(v)||0, 0, maxG);
  st.locked = true;
  renderMeal();
}
window.removeEntry = function(id){
  log = log.filter(e=>e.id!==id);
  save('log', log);
  renderAll();
}

$('btnReset').addEventListener('click', ()=>{
  const tk=todayKey();
  log = log.filter(e=>e.day!==tk);
  save('log', log);
  renderAll();
});

$('btnClearMeal').addEventListener('click', ()=>{
  meal = [];
  doseAdjustState = {};
  renderMeal();
});

$('mealType').addEventListener('change', ()=>{ renderMeal(); });

function setProfileFormValues(data){
  $('profileWeight').value = data.weightKg ?? '';
  $('profileHeight').value = data.heightCm ?? '';
  $('profileAge').value = data.age ?? '';
  $('profileGoal').value = data.goal || 'Mantenimento';
  $('profileWorkouts').value = data.workoutsPerWeek ?? '';
  $('profileWorkoutTime').value = data.workoutTime || '13:00';
  $('profileProtein').value = data.protein ?? '';
  $('profileCarbs').value = data.carbs ?? '';
  $('profileFat').value = data.fat ?? '';
  $('profileKcal').value = data.kcal ?? '';
}

function readProfileFormValues(){
  const num = (id)=>{
    const raw = String($(id).value || '').trim();
    return raw === '' ? NaN : Number(raw);
  };
  return {
    weightKg: num('profileWeight'),
    heightCm: num('profileHeight'),
    age: num('profileAge'),
    goal: $('profileGoal').value,
    workoutsPerWeek: num('profileWorkouts'),
    workoutTime: $('profileWorkoutTime').value || '13:00',
    protein: num('profileProtein'),
    carbs: num('profileCarbs'),
    fat: num('profileFat'),
    kcal: num('profileKcal'),
    isWorkoutDay: !!$('isWorkout').checked
  };
}

function normalizeProfilePayload(raw){
  const out = {};
  const numericFields = ['weightKg','heightCm','age','workoutsPerWeek','protein','carbs','fat','kcal'];
  for(const k of numericFields){
    const v = Number(raw[k]);
    if(Number.isFinite(v)) out[k] = v;
  }
  out.goal = raw.goal || 'Mantenimento';
  out.workoutTime = raw.workoutTime || '13:00';
  out.isWorkoutDay = !!raw.isWorkoutDay;
  return out;
}

function validateProfile(raw){
  const numericFields = ['weightKg','heightCm','age','workoutsPerWeek','protein','carbs','fat','kcal'];
  for(const key of numericFields){
    const v = raw[key];
    if(Number.isFinite(v) && v < 0){
      return `${key} non puÃ² essere negativo`;
    }
  }
  const required = ['kcal','protein','carbs','fat'];
  for(const key of required){
    if(!Number.isFinite(raw[key])) return 'Compila i target richiesti: kcal + P + C + F';
  }
  return '';
}

function openProfilePanel(){
  profileDraft = { ...profile };
  setProfileFormValues(profileDraft);
  $('profileError').textContent = '';
  $('profilePanel').style.display = 'block';
}

function closeProfilePanel(resetDraft=false){
  if(resetDraft){
    profileDraft = { ...profile };
    setProfileFormValues(profileDraft);
  }
  $('profileError').textContent = '';
  $('profilePanel').style.display = 'none';
}

$('isWorkout').addEventListener('change', ()=>{
  isWorkout = $('isWorkout').checked;
  save('isWorkout', isWorkout);
  profileDraft.isWorkoutDay = isWorkout;
  renderAll();
});

$('btnProfileToggle').addEventListener('click', ()=>{
  const open = $('profilePanel').style.display !== 'none';
  if(open) closeProfilePanel(true);
  else openProfilePanel();
});

$('btnProfileClose').addEventListener('click', ()=>{
  closeProfilePanel(true);
});

$('btnProfileSave').addEventListener('click', ()=>{
  const raw = readProfileFormValues();
  const validationError = validateProfile(raw);
  if(validationError){
    $('profileError').textContent = validationError;
    return;
  }
  profile = normalizeProfilePayload(raw);
  profileDraft = { ...profile };
  isWorkout = !!profile.isWorkoutDay;
  $('isWorkout').checked = isWorkout;
  save('isWorkout', isWorkout);
  saveProfile(profile);
  closeProfilePanel(false);
  renderAll();
});

$('btnSearch').addEventListener('click', searchAndRender);
$('q').addEventListener('keydown', (e)=>{ if(e.key==='Enter') searchAndRender(); });

async function searchAndRender(){
  const q = $('q').value.trim();
  if(!q) return;
  if(dbLoadError){
    $('results').innerHTML = `<div class="muted">Ricerca disabilitata: database locale non disponibile.</div>`;
    return;
  }

  $('results').innerHTML = `<div class="muted">Cerco offline â€œ${escapeHtml(q)}â€â€¦</div>`;

  let grouped;
  try{
    grouped = await searchFoodsByTerm(q);
  }catch(e){
    $('results').innerHTML = `<div class="muted">Errore nella ricerca locale. Verifica il file data/foods_it_master.json.</div>`;
    return;
  }

  if(!grouped.length){
    $('results').innerHTML = `<div class="muted">Inserisci almeno un termine valido.</div>`;
    return;
  }

  const sections = [];
  const flat = [];
  const foods = await loadLocalFoods();
  for(const group of grouped){
    const cards = group.results.map((r)=>{
      const idx = flat.push(r) - 1;
      return `
        <div class="item">
          <div>
            <b>${escapeHtml(r.name)} <span class="meta">${escapeHtml(r.hint||'')}</span></b>
            <div class="meta">Fonte: ${r.source} â€¢ per 100g: ${r1(r.per100.kcal)} kcal Â· P ${r01(r.per100.protein)} Â· C ${r01(r.per100.carbs)} Â· F ${r01(r.per100.fat)} Â· Fib ${r01(r.per100.fiber)}</div>
            <div class="meta">Score suggerito: <b>${r01(r.score)}/10</b></div>
          </div>
          <div class="right">
            <button class="btn primary" onclick="addResult(${idx})">Aggiungi</button>
          </div>
        </div>
      `;
    }).join('');

    const suggestions = (!group.results.length) ? getSuggestions(foods, group.term, 3) : [];
    const suggestionHtml = suggestions.length
      ? `<div class="muted" style="margin-bottom:10px;">Nessun risultato. Forse intendevi: <b>${suggestions.map((s)=>escapeHtml(s.name)).join(' â€¢ ')}</b></div>`
      : '<div class="muted" style="margin-bottom:10px;">Nessun risultato.</div>';

    sections.push(`
      <div style="margin-top:10px;">
        <div class="kicker" style="margin-bottom:8px;">Termine: <b>${escapeHtml(group.term)}</b></div>
        ${cards || `${suggestionHtml}${customFormHtml(group.term, `g${sections.length}`)}`}
      </div>
    `);
  }

  window.__lastResults = flat;
  $('results').innerHTML = sections.join('');
}

window.addResult = function(idx){
  const r = window.__lastResults[idx];
  if(!r) return;
  meal.push(r);
  doseAdjustState = {};
  renderMeal();
}

window.toggleCustomForm = function(key){
  const wrap = $(`customFormWrap-${key}`);
  const t = $(`customToggle-${key}`);
  if(!wrap || !t) return;
  const open = wrap.style.display !== 'none';
  wrap.style.display = open ? 'none' : 'block';
  t.classList.toggle('open', !open);
}

window.cancelCustomForm = function(key){
  const err = $(`customError-${key}`);
  if(err){ err.style.display='none'; err.textContent=''; }
  const wrap = $(`customFormWrap-${key}`);
  const t = $(`customToggle-${key}`);
  if(wrap) wrap.style.display = 'none';
  if(t) t.classList.remove('open');
}

window.saveCustomFood = async function(key){
  const name = ($(`customName-${key}`)?.value || '').trim();
  const kcal = Number($(`customKcal-${key}`)?.value || 0);
  const carbs = Number($(`customCarbs-${key}`)?.value || 0);
  const protein = Number($(`customProtein-${key}`)?.value || 0);
  const fat = Number($(`customFat-${key}`)?.value || 0);
  const fiber = Number($(`customFiber-${key}`)?.value || 0);
  const err = $(`customError-${key}`);
  const fail = (msg)=>{ if(err){ err.style.display='block'; err.textContent=msg; } };

  if(!name) return fail('Nome obbligatorio.');
  if([kcal, carbs, protein, fat, fiber].some((x)=>!isFinite(x) || x < 0)) return fail('I valori numerici devono essere >= 0.');
  if(kcal < 0 || kcal > 900) return fail('kcal deve essere tra 0 e 900.');

  const customFood = {
    name,
    aliases: [],
    per100: { kcal, carbs, protein, fat, fiber },
    category: 'altro',
    source: 'Custom',
    hint: '(personalizzato)',
    score: guessScore(name, fiber)
  };

  const normKey = normalizeForMatch(name);
  const existing = customFoods.findIndex((f)=>normalizeForMatch(f.name)===normKey);
  if(existing >= 0) customFoods[existing] = customFood;
  else customFoods.push(customFood);

  save('customFoods', customFoods);
  refreshFoodsCache();

  window.__lastResults = window.__lastResults || [];
  window.__lastResults.unshift(customFood);
  meal.push(customFood);
  doseAdjustState = {};
  renderMeal();
  $('results').innerHTML = `<div class="muted">Alimento personalizzato salvato: <b>${escapeHtml(name)}</b>. Ora Ã¨ ricercabile e aggiunto al pasto corrente.</div>`;
}

$('btnLog').addEventListener('click', ()=>{
  if(!meal.length) return alert('Aggiungi almeno un alimento al pasto.');
  const doses = suggestDoses().doses;

  const items = doses.map(d=>{
    const m = macrosForGrams(d.per100, d.grams);
    return { name: d.name, grams: d.grams, score: d.score, ...m };
  });

  const entry = {
    id: (crypto?.randomUUID?.() || String(Date.now()+Math.random())),
    day: todayKey(),
    mealType: $('mealType').value,
    createdAt: new Date().toISOString(),
    items
  };

  log.unshift(entry);
  save('log', log);
  renderAll();
});

setProfileFormValues(profileDraft);
loadLocalFoods().catch(()=>{}).finally(()=>renderAll());
</script>
</body>
</html>
